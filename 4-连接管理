#1 ====================================================================================================================

只要服务端/客户端不异常关机，那么TCP链接一旦建立起来，就会保证传输数据的可靠性
如果某一端异常关机，那么对端会收到链接异常关闭的通知

#2 ====================================================================================================================

SSL存在于HTTP和TCP之间，对TCP内容进行加密，然后使用HTTP作为运输载体进行传输。这个操作成为“隧道”

#3 ====================================================================================================================

4要素(本地ip，本地端口，对端ip，对端端口)决定了一个tcp连接，一个tcp连接对应两个socket，一个在本地，一个在对端

#4 ====================================================================================================================

HTTP作为应用层协议，紧密依靠TCP，所以TCP的性能直接决定了HTTP的性能表现

HTTP事务处理的流程极短，除非是并发性能出现瓶颈，所以大多数情况下，http的“慢”是由于TCP的“慢”造成的

总的来说，HTTP的慢有如下几点:
1）DNS域名解析可能会消耗十秒的时间，浏览器中如果直接输入ip地址，这里可以省掉
2）TCP链接的创建，即 三次握手 ，会消耗1~2秒
3）HTTP报文的组装和解析

#5 ====================================================================================================================

#以下内容会造成TCP时延：
1）TCP链接建立握手  (这个无法避免)
	（*）影响：握手的交互会消耗时间

2）TCP慢启动拥塞控制  （为了整个网络考虑，可以理解）

	--拥塞控制--
	当链路中有大量数据时，TCP通过调节滑动窗口的宽度来调节发送队列中的数据量，当拥塞时，通过缩小窗口来使“发送-确认”
	队列数下降，从而达到缓解拥塞的目的。
	滑动窗口相当于 TCP 到 IP 的“门”

	--慢启动--
	不使用慢启动时，应用程序初次发送数据可能会一股脑把数据都丢到网络上去，这样虽然提高了效率，让数据能够尽可能地
	抢占带宽资源，但是负面效果就是 “数据在路由器位置大量积压，耗尽路由器缓存”，从而导致网络拥塞。
	慢启动的思路就是 --> 初次发送时，循序渐进地增加滑动窗口，然流量缓慢进入网络。

	（*）影响：拥塞控制就意味着 为了 网络健康，放弃部分效率，所以效果就是“慢一点”

	PS:当链路拥塞的时候，可能会随意地丢弃数据包，TCP有分组确认机制，确保丢包重发


3）Nagle算法  （为了提高带宽效率）

	Nagle算法的本质就是  “把多个小的TCP数据放在同一个TCP包中，然后在包裹IP发出去” ，提高了效率，但是实效性受到了
	影响，因为小的数据包会在等待区等着别人来和他拼车，不然黑车司机(TCP组包流程)不发车。

	（*）拼车就要等，时效性就低，如果想要快，那么这里可以考虑优化或省略，如果都是大数据包，Nagle算法不会被触发

	在setsockopt函数中，可以设置TCP_NODELAY来关闭Nagle算法
	
	Nagle算法是针对TCP数据的，把多个TCP数据包打包在一起放入IP协议中传输。


4）用于捎带确认的TCP延迟确认算法

5）TIME_WAIT累积和端口耗尽
	
	TIME_WAIT是只TCP连接被释放后，TCP协议栈为继续持有这个TCP链接对应的端口号，标注为"近期被使用过，2MSL时间内
	不准被使用"，这样做的目的在于 “如果端口号立即被分配给别的应用，而上一次使用这个端口的应用程序还有残留数据
	在网络上路由，这样就会张冠李戴，导致后一个应用收到了前一个应用残留的数据”。

	端口耗尽，一般是由于DOS 和 DDOS造成，根本原因是TIME_WAIT机制。

	（*）如果必须，可以吧2MSL值设小一点，但是这样必须保证应用程序在设计的时候，会以某些字段标记来判断报文是不是发给
	自己的。防止张冠李戴的情况出现。
	
	客户端在进行并发访问服务器的时候，并发容量受端口数量的影响，因为机器端口一般为60000个，那么2MSL时间内，每秒
	最多能创建60000/120 = 500个，超过这个数量的时候，客户端将不再有多余的端口可使用。

	（*）在服务端，监听端口（服务端口）只有一个，之所以会有一个端口能够服务N多连接，那是因为客户端的端口+ip是不重复
	的，这样4要素就是不重复的。
	（*）切记，服务端不会创建新端口来服务端客户端，只会有新的套接字来服务客户端，而这些套接字都有相同的服务端ip+端口
	，只是客户端ip+端口各不相同而已。


#有关丢包
丢包是指 IP 层数据包丢失，丢包，比特错误和噪声，三个问题决定了网络传输正确率的好坏

丢包的原因有：1）信号衰减 2）链路拥塞 3）损坏数据包被过滤 4）驱动程序故障

丢包的重发和撤销，是由TCP层控制的，TCP链接一旦建立，双方就会对交互的IP包进行统计，如果发现有丢包情况，则会要求
对端重发，或者也可以不让对端重发，默认接受丢包现象

UDP没有丢包重传机制，因此如果想要有丢包重传，需要自己在UDP层或者在应用层实现。



#6 ====================================================================================================================

TCP的长链接和短链接

（！！！！）概念：所谓的 长连接 和 短链接 是不存在的！！！！所有连接都是短链接，长连接是指 短链接+保活机制
只是为了区分，才有了长连接和短链接的名词！！！
所有的TCP链接都是一样的，都是短链接！！！！

setsockopt 配和 SO_KEEPALIVE 使用，开启保活机制

#长连接

正常情况下，双端在关闭socket的时候，会给对端发送TCP挥手报文，告知“本端已经关闭连接了，对端也可以关闭了”，但是！如果
某一段网线被拔了，电脑断电了等物理上的问题，这个挥手动作就不会被触发。这样，另外一段就只能傻等，起始对端已经没法再
重新连接了。这个问题会导致一段的socket无法被释放，因为不知道对端是什么情况。

这个时候可以在应用中增加心跳检测机制来完成对“垃圾连接”的清理，当发送心跳报文后没有收到回复，则可以认为对端因为某种
原因而“不行了”，此时可以淡然地关闭连接。

此外，也可以为socket设置TCP选项，让心跳机制由TCP来维护。这样可以让应用程序从心跳维护中解脱出来。

Linux下，可以使用如下命令查看长连接的配置：

$ sysctl -a | grep keepalive
net.ipv4.tcp_keepalive_time = 7200		//链接建立后，多少秒后，开始启动心跳检测
net.ipv4.tcp_keepalive_probes = 9		//连续发送多少个心跳后，对端都没有应答，那么认为对端“已死”
net.ipv4.tcp_keepalive_intvl = 75		//每个心跳之间的间隔

计算  7200 + 9*75 = 7875 秒 。合计2.1875 小时。即连续两小时没有收到长连接上的心跳报文，TCP协议栈会认为对端“已死”

客户端异常关闭，或是网络断开。在这两种情况下， client 端都不会响应。服务器没有收到对其发出探测的响应，并且在一定时间后重
复发送 keep-alive packet ，并且重复发送一定次数。重复发送次数后没有收到响应，则会进入TIME_WAIT状态，此状态下等待2*MSL时间
后连接关闭。MSL，即Maximum Segment Lifetime，是一个数据分片（报文）在网络中能够生存的最长时间，在RFC 793中定义MSL通常为2
分钟。

客户端曾经崩溃，但已经重启。这种情况下，服务器将会收到对其存活探测的响应，但该响应是一个复位，从而引起服务器对连接的终止


#短链接
所有TCP链接都是短链接，只是没有附加“保活机制”而已，如果加了，则TCP链接具备探测对端“死活”的能力，这就是长连接。
如果没加，要么自己在应用层实现自己的“保活机制”，要么就无法知道对端死活，这就是所谓的短链接。

不论是所谓的长连接还是所谓的短链接，他们都是TCP链接，都要遵守TCP的 “三次握手” 和 “四次挥手”



#7 ====================================================================================================================
持久连接



#1 ====================================================================================================================

#1 ====================================================================================================================

#1 ====================================================================================================================
#1 ====================================================================================================================
#1 ====================================================================================================================
#1 ====================================================================================================================
#1 ====================================================================================================================


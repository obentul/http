TCP的长链接和短链接

（！！！！）概念：所谓的 长连接 和 短链接 是不存在的！！！！所有连接都是短链接，长连接是指 短链接+保活机制
只是为了区分，才有了长连接和短链接的名词！！！
所有的TCP链接都是一样的，都是短链接！！！！

setsockopt 配和 SO_KEEPALIVE 使用，开启保活机制

#长连接

正常情况下，双端在关闭socket的时候，会给对端发送TCP挥手报文，告知“本端已经关闭连接了，对端也可以关闭了”，但是！如果
某一段网线被拔了，电脑断电了等物理上的问题，这个挥手动作就不会被触发。这样，另外一段就只能傻等，起始对端已经没法再
重新连接了。这个问题会导致一段的socket无法被释放，因为不知道对端是什么情况。

这个时候可以在应用中增加心跳检测机制来完成对“垃圾连接”的清理，当发送心跳报文后没有收到回复，则可以认为对端因为某种
原因而“不行了”，此时可以淡然地关闭连接。

此外，也可以为socket设置TCP选项，让心跳机制由TCP来维护。这样可以让应用程序从心跳维护中解脱出来。

Linux下，可以使用如下命令查看长连接的配置：

$ sysctl -a | grep keepalive
net.ipv4.tcp_keepalive_time = 7200              //链接建立后，多少秒后，开始启动心跳检测
net.ipv4.tcp_keepalive_probes = 9               //连续发送多少个心跳后，对端都没有应答，那么认为对端“已死”
net.ipv4.tcp_keepalive_intvl = 75               //每个心跳之间的间隔

计算  7200 + 9*75 = 7875 秒 。合计2.1875 小时。即连续两小时没有收到长连接上的心跳报文，TCP协议栈会认为对端“已死”

客户端异常关闭，或是网络断开。在这两种情况下， client 端都不会响应。服务器没有收到对其发出探测的响应，并且在一定时间后重
复发送 keep-alive packet ，并且重复发送一定次数。重复发送次数后没有收到响应，则会进入TIME_WAIT状态，此状态下等待2*MSL时间
后连接关闭。MSL，即Maximum Segment Lifetime，是一个数据分片（报文）在网络中能够生存的最长时间，在RFC 793中定义MSL通常为2
分钟。

客户端曾经崩溃，但已经重启。这种情况下，服务器将会收到对其存活探测的响应，但该响应是一个复位，从而引起服务器对连接的终止


#短链接
所有TCP链接都是短链接，只是没有附加“保活机制”而已，如果加了，则TCP链接具备探测对端“死活”的能力，这就是长连接。
如果没加，要么自己在应用层实现自己的“保活机制”，要么就无法知道对端死活，这就是所谓的短链接。

不论是所谓的长连接还是所谓的短链接，他们都是TCP链接，都要遵守TCP的 “三次握手” 和 “四次挥手”
